PARSER_BEGIN(MyNewGrammar)

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

import javax.swing.JFileChooser;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class MyNewGrammar {
  public static void main(String[] args) throws ParseException {
          // Arquivo selecionado
          InputStream inputStream = null;

          // Criar um seletor de arquivos
          JFileChooser fileChooser = new JFileChooser();
          fileChooser.setDialogTitle("Select a file to parse");

          // Mostrar o diálogo de abertura; este método não retorna até que o diálogo seja fechado
          int result = fileChooser.showOpenDialog(null);

          // Se o usuário selecionar um arquivo
          if (result == JFileChooser.APPROVE_OPTION) {
              try {
                  inputStream = new FileInputStream(fileChooser.getSelectedFile());
                  System.out.println("File upload: " + fileChooser.getSelectedFile().getPath());
              } catch (FileNotFoundException e) {
                  System.out.println("File not found: " + fileChooser.getSelectedFile().getPath());
                  return;
              }
          } else {
              System.out.println("No file selected. Exiting.");
              return;
          }

          // Ler o arquivo linha por linha
          try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
              String line = reader.readLine();
               System.out.println("LineF: " + line);
              while (line!= null && line!="") {
                  System.out.println("Processing line: " + line);
                  // Processar a linha conforme necessário
                  processLine(line);
                  line = reader.readLine();
                  System.out.println("LineD: " + line);
              }
          } catch (IOException e) {
              System.out.println("Error reading the file: " + e.getMessage());
          }
      }

      // Método para processar cada linha
      private static void processLine(String line) {
          try {
              // Processar a linha com o seu código atual
              switch (MyNewGrammar.one_line()) {
                  case 0:
                      System.out.println("OK.");
                      break;
                  case 1:
                      System.out.println("Goodbye.");
                      break;
                  default:
                      System.out.println("Default...");
                      break;
              }
          } catch (Exception e) {
              System.out.println("NOK.");
              System.out.println(e.getMessage());
          } catch (Error e) {
              System.out.println("Oops.");
              System.out.println(e.getMessage());
          }
      }
}

PARSER_END(MyNewGrammar)

// Espaços em branco
SKIP : {
  " " | "\r" | "\t" | "\n"
}

// Operadores
TOKEN : {
    <ATRIBUICAO: "=" >
  | <MAIOR: ">" >
  | <MENOR: "<" >
  | <NEGACAO: "!" >
  | <DOIS_PONTOS: ":" >
  | <IGUAL: "==" >
  | <ESTRITAMENTE_IGUAL: "===" >
  | <MENOR_IGUAL: "<=" >
  | <MAIOR_IGUAL: ">=" >
  | <DIFERENTE: "!=" >
  | <ESTRITAMENTE_DIFERENTE: "!==" >
  | <OR: "||" >
  | <AND: "&&" >
  | <INCREMENTO: "++" >
  | <DECREMENTO: "--" >
  | <MAIS: "+" >
  | <MENOS: "-" >
  | <ASTERISCO: "*" >
  | <BARRA: "/" >
  | <PORCENTO: "%" >
  | <MAIS_IGUAL: "+=" >
  | <MENOS_IGUAL: "-=" >
  | <ASTERISCO_IGUAL: "*=" >
  | <BARRA_IGUAL: "/=" >
  | <PORCENTO_IGUAL: "%=" >
}

// Delimitadores
TOKEN : {
    <ABRE_PARENTESES: "(">
  | <FECHA_PARENTESES: ")">
  | <ABRE_CHAVE: "{">
  | <FECHA_CHAVE: "}">
  | <ABRE_COLCHETE: "[">
  | <FECHA_COLCHETE: "]">
  | <PONTO_VIRGULA: ";">
  | <VIRGULA: ",">
  | <PONTO: ".">
}

// Palavras reservadas
TOKEN : {
    <CLASS: "class">
  | <NaN: "NaN">
  | <VOID: "void">
  | <RETURN: "return">
  | <STATIC: "static">
  | <IF: "if">
  | <ELSE: "else">
  | <TRUE: "true">
  | <FALSE: "false">
  | <CONSOLE: "console">
  | <LOG: "log">
  | <PROMPT: "prompt">
  | <WHILE: "while">
  | <BREAK: "break">
  | <CONTINUE: "continue">
  | <FUNCTION: "function">
}

// Tipos primitivos e literais
TOKEN : {
    <STRING_LITERAL: "\"" (~["\"","\\"] | "\\" ["\"","\\","b","f","n","r","t"])* "\"" |
                     "'" (~["'","\\"] | "\\" ["'","\\","b","f","n","r","t"])* "'">
  // | <IDENTIFIER: (["a"-"z", "A"-"Z", "_", "$", "ª", "º"]) (["a"-"z", "A"-"Z", "0"-"9", "_",  "$", "ª", "º"])*>
  |<IDENTIFIER: (["a"-"z", "A"-"Z", "_", "$", "ª", "º"])+>
  | <NUMBER: (["0"-"9"])+ ("." (["0"-"9"])+)? >
  | <BIGINT: (["0"-"9"])+ "n">
  | <UNDEFINED: "undefined">
  | <NULL: "null">
  | <BOOLEAN: ("true" | "false")>
  | <SYMBOL: "Symbol" "(" (~["\"","\\"] | "\\" ["\"","\\","b","f","n","r","t"])* ")">
}

// Declaração de variáveis
TOKEN : {
    <LET: "let">
  | <VAR: "var">
}

TOKEN : {
    <CONSTANT : (<DIGIT>)+>
  | <#DIGIT : ["0"-"9"]>
}
// Regras gramaticais
void program() : {} {
    (consoleLog() | variableDeclaration() /*| functionDeclaration()*/ | assignment())* <EOF>
}

void consoleLog() : {} {
    <CONSOLE> <PONTO> <LOG> <ABRE_PARENTESES> argumentList() <FECHA_PARENTESES> (<PONTO_VIRGULA>)?
}

void argumentList() : {} {
    (value() ( <VIRGULA> value() )*)?
}

void variableDeclaration() : {} {
    ( <LET> | <VAR> ) <IDENTIFIER> <ATRIBUICAO> value() (<PONTO_VIRGULA>)?
}

/*void functionDeclaration() : {} {
    <FUNCTION> <IDENTIFIER> <ABRE_PARENTESES> parameterList() <FECHA_PARENTESES> <ABRE_CHAVE> (assignment() | functionCall())* <FECHA_CHAVE>
}*/

void parameterList() : {} {
    ( <IDENTIFIER> ( <VIRGULA> <IDENTIFIER> )* )?
}

void assignment() : {} {
    <IDENTIFIER> <ATRIBUICAO> value() (<PONTO_VIRGULA>)?
}

/*void functionCall() : {} {
    <IDENTIFIER> <ABRE_PARENTESES> argumentList() <FECHA_PARENTESES> (<PONTO_VIRGULA>)?
}*/

void value() : {} {
    <NUMBER> | <BOOLEAN> | <NULL> | <UNDEFINED> | <STRING_LITERAL> | <IDENTIFIER> | <ABRE_PARENTESES> value() <FECHA_PARENTESES>
}

int one_line() : {} {
    sum() <PONTO_VIRGULA> { return 0; } | <PONTO_VIRGULA> { return 1; }
}

void sum() : {} {
    term() ( ( <MAIS> | <MENOS> ) term() )*
}

void term() : {} {
    unary() ( ( <ASTERISCO> | <BARRA> ) unary() )*
}

void unary() : {} {
    <MENOS> element() | element()
}

void element() : {} {
    <CONSTANT> | <ABRE_PARENTESES> sum() <FECHA_PARENTESES>
}


