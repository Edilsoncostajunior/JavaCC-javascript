PARSER_BEGIN(MyNewGrammar)

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

import javax.swing.JFileChooser;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;


public class MyNewGrammar
{
  public static void main(String args []) throws ParseException
  {
    MyNewGrammar parser = new MyNewGrammar(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      System.out.print("Enter any expression from javascript :");
      try
      {
          if (MyNewGrammar.one_line() == 0){
            System.out.println("OK.");
            break;
          }else if(MyNewGrammar.one_line() == 1){
            System.out.println("Goodbye.");
            break;
          }
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        MyNewGrammar.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }
}

PARSER_END(MyNewGrammar)

// Espaços em branco
SKIP : {
  " " | "\r" | "\t" | "\n"
}

// Operadores
TOKEN : {
    <ATRIBUICAO: "=" >
  | <MAIOR: ">" >
  | <MENOR: "<" >
  | <NEGACAO: "!" >
  | <DOIS_PONTOS: ":" >
  | <IGUAL: "==" >
  | <ESTRITAMENTE_IGUAL: "===" >
  | <MENOR_IGUAL: "<=" >
  | <MAIOR_IGUAL: ">=" >
  | <DIFERENTE: "!=" >
  | <ESTRITAMENTE_DIFERENTE: "!==" >
  | <OR: "||" >
  | <AND: "&&" >
  | <INCREMENTO: "++" >
  | <DECREMENTO: "--" >
  | <MAIS: "+" >
  | <MENOS: "-" >
  | <ASTERISCO: "*" >
  | <BARRA: "/" >
  | <PORCENTO: "%" >
  | <MAIS_IGUAL: "+=" >
  | <MENOS_IGUAL: "-=" >
  | <ASTERISCO_IGUAL: "*=" >
  | <BARRA_IGUAL: "/=" >
  | <PORCENTO_IGUAL: "%=" >
}

// Delimitadores
TOKEN : {
    <ABRE_PARENTESES: "(">
  | <FECHA_PARENTESES: ")">
  | <ABRE_CHAVE: "{">
  | <FECHA_CHAVE: "}">
  | <ABRE_COLCHETE: "[">
  | <FECHA_COLCHETE: "]">
  | <PONTO_VIRGULA: ";">
  | <VIRGULA: ",">
  | <PONTO: ".">
}

// Palavras reservadas
TOKEN : {
    <CLASS: "class">
  | <NaN: "NaN">
  | <VOID: "void">
  | <RETURN: "return">
  | <STATIC: "static">
  | <IF: "if">
  | <ELSE: "else">
  | <TRUE: "true">
  | <FALSE: "false">
  | <CONSOLE: "console">
  | <LOG: "log">
  | <PROMPT: "prompt">
  | <WHILE: "while">
  | <BREAK: "break">
  | <CONTINUE: "continue">
  | <FUNCTION: "function">
}

// Tipos primitivos e literais
TOKEN : {
    <STRING_LITERAL: "\"" (~["\"","\\"] | "\\" ["\"","\\","b","f","n","r","t"])* "\"" |
                     "'" (~["'","\\"] | "\\" ["'","\\","b","f","n","r","t"])* "'">
  | <IDENTIFIER: (["a"-"z", "A"-"Z", "_", "$", "ª", "º"]) (["a"-"z", "A"-"Z", "0"-"9", "_",  "$", "ª", "º"])*>
  | <NUMBER: (["0"-"9"])+ ("." (["0"-"9"])+)? >
  | <BIGINT: (["0"-"9"])+ "n">
  | <UNDEFINED: "undefined">
  | <NULL: "null">
  | <BOOLEAN: ("true" | "false")>
  | <SYMBOL: "Symbol" "(" (~["\"","\\"] | "\\" ["\"","\\","b","f","n","r","t"])* ")">
}

// Declaração de variáveis
TOKEN : {
    <LET: "let">
  | <VAR: "var">
}

TOKEN : {
    <CONSTANT : (<DIGIT>)+>
  | <#DIGIT : ["0"-"9"]>
}
// Regras gramaticais
void program() : {} {
    (consoleLog()  /*| variableDeclaration() | functionDeclaration() | assignment()*/)* (<PONTO_VIRGULA>)?
}

void consoleLog() : {} {
    <CONSOLE> <PONTO> <LOG> <ABRE_PARENTESES> argumentList()  <FECHA_PARENTESES>
}

void argumentList() : {} {
    (value() ( <VIRGULA> value() )*)?
}

void variableDeclaration() : {} {
    ( <LET> | <VAR> ) <IDENTIFIER> <ATRIBUICAO> value() (<PONTO_VIRGULA>)?
}

/*void functionDeclaration() : {} {
    <FUNCTION> <IDENTIFIER> <ABRE_PARENTESES> parameterList() <FECHA_PARENTESES> <ABRE_CHAVE> (assignment() | functionCall())* <FECHA_CHAVE>
}*/

void parameterList() : {} {
    ( <IDENTIFIER> ( <VIRGULA> <IDENTIFIER> )* )?
}

void assignment() : {} {
    <IDENTIFIER> <ATRIBUICAO> value() (<PONTO_VIRGULA>)?
}

void functionCall() : {} {
    <IDENTIFIER> <ABRE_PARENTESES> argumentList() <FECHA_PARENTESES> (<PONTO_VIRGULA>)?
}

void value() : {} {
    <NUMBER> | <BOOLEAN> | <NULL> | <UNDEFINED> | <STRING_LITERAL> | <IDENTIFIER> | <ABRE_PARENTESES> value() <FECHA_PARENTESES>
}

int one_line() : {} {
    program()  { return 0; } | <PONTO_VIRGULA> { return 1; }
}

void sum() : {} {
    term() ( ( <MAIS> | <MENOS> ) term() )*
}

void term() : {} {
    unary() ( ( <ASTERISCO> | <BARRA> ) unary() )*
}

void unary() : {} {
    <MENOS> element() | element()
}

void element() : {} {
    <CONSTANT> | <ABRE_PARENTESES> sum() <FECHA_PARENTESES>
}


